#!/bin/bash

# Like nearly everything in SWE, the file is covered by the project's
#   umbrella GPL license.

# Tweaks to handle DHCP changes by Neal Murphy and Stan Prescott, 4/2013
# Re-arranged a little and ip-up merged in; Neal Murphy, 7/2013
# Console output expanded to dump to console, syslog (smoothwall) and/or
#   syslog (dhcpcd debugging); Murphy/Jones, 2015

# A bit of shorthand
ethDIR="/var/smoothwall/ethernet"
pppDIR="/var/smoothwall/ppp"
redDIR="/var/smoothwall/red"

. /etc/rc.d/inc.rc-functions

dns1ENV=$DNS1
dns2ENV=$DNS2
. ${ethDIR}/settings


# readRED: read the data files in .../red/*
function readRED {
	case $RED_TYPE in
	  DHCP)
	    RED_ADDRESS=`cat $redDIR/local-ipaddress`
	    RED_GATEWAY=`cat $redDIR/remote-ipaddress`
	    RED_NETMASK=`cat $redDIR/dhcp-netmask`
	    RED_DNS1=`cat $redDIR/dns1`
	    RED_DNS2=`cat $redDIR/dns2`
	    ;;
	  *)
	    echolog "" "s" "$DEBUG_DHCPCD" "..readRED called for invalid red type '$RED_TYPE'"
	    exit 0
	    ;;
	esac
}

# writeRED: write the data files in .../red/*
function writeRED {
	echo -n $1 >$redDIR/iface
	echo -n $2 >$redDIR/local-ipaddress
	echo -n $3 >$redDIR/remote-ipaddress
	echo -n $4 >$redDIR/dhcp-netmask
	echo -n $5 >$redDIR/dns1
	echo -n $6 >$redDIR/dns2
	> $redDIR/active
	chown nobody:nobody $redDIR/*
}



# writeDHCPinfo: writes out the dhcpcd-6.9.0 data to the expected location and format for legacy support:
function writeDHCPinfo {
        echolog "$crDEBUG" "" "$DEBUG_DHCPCD" "..enter rc.updatered function writeDHCPinfo ($reason) [`date`]"
	# Compat enter hook shim for older dhcpcd versions
        
        # dhcpcd information file (used by various parts of the system):
        info_dir="/var/lib/dhcpcd"
        info_file="$info_dir"/dhcpcd-"$interface".info

        # check for existence of /var/lib/dhcpcd directory
        if [ ! -d "$info_dir" ]; then
              mkdir "$info_dir"
        fi
	# remove crumbs from prior dhcpcd lease:
        
        # get the epoch time as equivalent of old dhcpcd LEASEDFROM (legacy):
        legacy_leasedfrom=$(date +%s)
        echolog "$crDEBUG" "" "$DEBUG_DHCPCD" "..rc.updatered function writeDHCPinfo: legacy_leasedfrom = $legacy_leasedfrom"

        # get the CLIENTID (legacy)
	client_duid=""
        if [ -e /usr/etc/dhcpcd.duid ]; then
                client_duid=$(< /usr/etc/dhcpcd.duid)
                echolog "$crDEBUG" "" "$DEBUG_DHCPCD" "..rc.updatered function writeDHCPinfo (file exists): client_duid = $client_duid"
        fi
        echolog "$crDEBUG" "" "$DEBUG_DHCPCD" "..rc.updatered function writeDHCPinfo: client_duid = $client_duid"
      
        # obtain the $RED_DEV mac address (legacy DHCPCADDR):
        red_macaddr=$(cat /sys/class/net/$interface/address)
        echolog "$crDEBUG" "" "$DEBUG_DHCPCD" "..rc.updatered function writeDHCPinfo (get red mac address): RED_MACADDR = $red_macaddr"

	IPADDR=$new_ip_address
	NETMASK=$new_subnet_mask
	NETWORK=$new_network_number
	BROADCAST=$new_broadcast_address
        MTU=$new_interface_mtu
        ROUTES=""
	GATEWAYS=$new_routers
        HOSTNAME=$RED_DHCP_HOSTNAME
	DNSDOMAIN=$new_domain_name
	DNSSERVERS=$new_domain_name_servers
	DHCPSID=$new_dhcp_server_identifier
        LEASEDFROM=$legacy_leasedfrom
        LEASETIME=$new_dhcp_lease_time
        RENEWALTIME=$new_dhcp_renewal_time
        REBINDTIME=$new_dhcp_rebinding_time
        INTERFACE=$interface
	CLASSID="dhcpcd 6.9.0"
        CLIENTID=$client_duid
	DHCPCADDR=$red_macaddr
        # these values were not being used previously
	DNSSEARCH=$new_domain_search
	NISDOMAIN=$new_nis_domain
	NISSERVERS=$new_nis_servers
	NTPSERVERS=$new_ntp_servers



	GATEWAY=
	for x in $new_routers; do
		GATEWAY="$GATEWAY${GATEWAY:+,}$x"
	done
	DNS=
	for x in $new_domain_name_servers; do
		DNS="$DNS${DNS:+,}$x"
	done

	r="down"
	case "$reason" in
	RENEW|BOUND) r="up";;
	REBOOT) r="new";;
	esac

	if [ "$r" != "down" ]; then
		rm -f "$info_file"
		for x in BROADCAST CLASSID CLIENTID DHCPCADDR DHCPSID \
			 DNSDOMAIN DNSSEARCH DNSSERVERS GATEWAYS HOSTNAME \
			 INTERFACE IPADDR LEASEDFROM LEASETIME MTU \
			 NETMASK NETWORK NISDOMAIN NISSERVERS NTPSERVERS \
			 REBINDTIME RENEWALTIME ROUTES; do
			eval echo "$x=\'\$$x\'" >> "$info_file"
		done

		# call writeRED to create these files immediately!
		writeRED $INTERFACE $IPADDR "$GATEWAYS" $NETMASK $DNSMASQ_DNS1 $DNSMASQ_DNS2
	fi

	set -- "$info_file" "$r"

}


echolog "$crDEBUG" "" "$DEBUG_DHCPCD" "..enter rc.updatered ($reason) [`date`]"

# New dhcpcd debug block:
# consider wrapping this in a DHCPCD_DEBUG conditional, perhaps add to $RED_DEV settings?
# will also need to check the size (line count) of the /tmp/dhcpcd-debug-environs.txt file
# and delete it after a set size limit to prevent the disk from being eaten! 
# The debug logs have been very helpful and may be helpful for troubleshooting as more dhcp servers are encountered after update deployment.
# try to exit this script under no-action scenarios with DHCP:

# Changed. If new reasons appear, we'll see them in the log. But we really only
#   care about BOUND, REBOOT, RENEW and STOP; we ignore all others.
#   EXPIRE*|EXPIRE6*|NAK*|FAIL*|CARRIER*|NOCARRIER*|PREINIT*|DEPARTED*|TIMEOUT*)

if [ "$RED_TYPE" == "DHCP" ]; then
    case $reason in
        BOUND|RENEW|STOP|STOPPED|REBOOT)
          # Do nothing; we care about only these
          ;;
	*)
          # Ignore all other reasons, known or not.
          echolog "$crDEBUG" "s" "$DEBUG_DHCPCD" "..Ignore DHCPCD callback reason '$reason'"
	  echolog "$crDEBUG" "" "$DEBUG_DHCPCD" "..exiting rc.updatered RED_TYPE [$RED_TYPE] ($reason) [`date`]"
          exit 0
          ;;
   esac
fi

# users can enable dhcpcd debug logging by simply creating an empty debug log file:
# touch "/tmp/dhcpcd-debug-environs.txt"
DHCPCD_DEBUG_FILE="/tmp/dhcpcd-debug-environs.txt"
DHCPCD_DEBUG=false

if [ -f "$DHCPCD_DEBUG_FILE" ]; then
        DHCPCD_DEBUG=true
fi

if [ "$RED_TYPE" == "DHCP" ] && [ "$DHCPCD_DEBUG" = true ]; then
	if [ -f "$DHCPCD_DEBUG_FILE" ]; then
 		# truncate it if it is too long (~5000 lines should be plenty of history) disk usage arbitrary size limit. Each run through ~5.2K file size):
                # (each event = 225 lines. 5400 lines = ~2 days of activity if lease is 1 hr and renewed @ leasetime/2)
                maxdhcpcddebugfile_lines=5400 #<-- might want this one UI configurable too 
                dhcpcddebugfile_lines=$(wc -l < "$DHCPCD_DEBUG_FILE")
                # check the line count vs. max line count in the debug log file:
		if [ "$dhcpcddebugfile_lines" -ge "$maxdhcpcddebugfile_lines" ]; then
                        tail -n "$maxdhcpcddebugfile_lines" "$DHCPCD_DEBUG_FILE" > "$DHCPCD_DEBUG_FILE".tmp
                        rm -f "$DHCPCD_DEBUG_FILE"
                        cat "$DHCPCD_DEBUG_FILE".tmp > "$DHCPCD_DEBUG_FILE"
                        rm -f "$DHCPCD_DEBUG_FILE".tmp
		fi
	fi

	touch "$DHCPCD_DEBUG_FILE"
	
	(
  	echo "As of `date`"
  	echo "Positional params"
  	for i in "$@"; do echo "  '$i'";done
	
	  echo "environment"
	  set
	  echo
	  echo "Second Param: " $2
	  echo "env reason: " $reason
	) >> "$DHCPCD_DEBUG_FILE"
fi
# end dhcpcd debug logging block


# Drop a trace
echolog "E" "s" "$crDEBUG_DHCPCD" "..Updating RED"


if [ "$RED_TYPE" == "DHCP" ]; then
	# First up; when RED is DHCP

	case $reason in
	  STOP|STOPPED)
	    # Nothing to do; either the system is going down or networking is
	    #   being stopped for restart. *Technically*, it might be more correct
	    #   to stop the various services; but since they are re-started soon
	    #   enough or the system halts, it might not matter.

	    echolog "" "s" "" "..DHCP lease lost; clear RED info"
            echolog "$crDEBUG" "" "$DEBUG_DHCPCD" "..DHCP lease lost; clear RED info. exit rc.updatered RED_TYPE [$RED_TYPE] ($reason) [`date`]"
	    writeRED
	    rm -f $redDIR/active
	    rm -f /var/lib/dhcpcd-"$INTERFACE".info
	    # This might could get annoying if the lease changes often
	    /usr/bin/sounds/offlinesound
            echolog "$crDEBUG" "" "$DEBUG_DHCPCD" "..DHCP lease link-DOWN; Exiting rc.updatered RED_TYPE [$RED_TYPE] ($reason) [`date`]"
	    echolog "" "s" "" "..DHCP lease lost (links or system going down). Reason: ($reason)"

	    exit 0
	    ;;

	  BOUND|RENEW)
	    # UP with or without changes
	    if [ "$new_ip_address" == "$old_ip_address" -a \
	         "$new_subnet_mask" == "$old_subnet_mask" -a \
	         "$new_routers" == "$old_routers" -a \
	         "$new_domain_name_servers" == "$old_domain_name_servers" ]; then
	      # Nothing changed, nothing to do
	      echolog "$crDEBUG" "" "$DEBUG_DHCPCD" "..DHCP lease link-up; no changes. exiting rc.updatered RED_TYPE [$RED_TYPE] ($reason) [`date`]"
	      echolog "" "s" "" "..DHCP lease renewed; no changes"
	      exit 0
	    else
	      # BOUND or RENEW with changes
	      echolog "" "s" "" "..DHCP lease renewed ($reason); WITH changes"
	    fi
	    # Fall through! (Obviously only if up with changes.)
	    ;&

	  REBOOT)
	    # new, or up with changes ($reason=BOUND|REBOOT|RENEW)
	    echolog "" "s" "" "..DHCP lease changed ($reason); updating RED info"
            echolog "$crDEBUG" "" "$DEBUG_DHCPCD" "..DHCP lease changed ($reason); updating RED info. rc.updatered RED_TYPE [$RED_TYPE] ($reason) [`date`]"
	    rm -f ${ethDIR}/bootUP

	    # Tap Marples' shim under the corner to level it off.
	    writeDHCPinfo
	    DNSMASQ_DNS1=`/usr/bin/smoothwall/getdnsfromdhcpc.pl 1`
	    DNSMASQ_DNS2=`/usr/bin/smoothwall/getdnsfromdhcpc.pl 2`
	    . /var/lib/dhcpcd/dhcpcd-${RED_DEV}.info

	    writeRED $INTERFACE $IPADDR "$GATEWAYS" \
		     $NETMASK $DNSMASQ_DNS1 $DNSMASQ_DNS2

	    # This might could get annoying if the lease changes often
	    /usr/bin/sounds/onlinesound
	    ;;
	esac


elif [ "$RED_TYPE" == "STATIC" ]; then
	# Second up; when RED is static
	#
	echolog "" "s" "" "..Setting RED's static IP info"
	if [ "$DNS1_OVERRIDE" != "" -o "$DNS2_OVERRIDE" != "" ]; then
		DNSMASQ_DNS1=$DNS1_OVERRIDE
		DNSMASQ_DNS2=$DNS2_OVERRIDE
	else
		DNSMASQ_DNS1=$DNS1
		DNSMASQ_DNS2=$DNS2
	fi
	writeRED $RED_DEV $RED_ADDRESS $DEFAULT_GATEWAY \
	         $RED_NETMASK $DNSMASQ_DNS1 $DNSMASQ_DNS2

	/usr/bin/sounds/onlinesound


else
	# Last: everything else is PPP
	#
	echolog "" "s" "" "..PPP is active on $1; updating RED info"

	# Do nothing if it's already active
	[ -e $redDIR/active ] && exit 0

	# Otherwise prepare and write the RED info
	. ${pppDIR}/settings

	if [ "$DNS" == "Automatic" ]; then
		# Use the addrs we got from the peer ppp daemon
		DNSMASQ_DNS1=$dns1ENV
		DNSMASQ_DNS2=$dns2ENV
	else
		# Use the addrs we got from our PPP settings file
		DNSMASQ_DNS1=$DNS1
		DNSMASQ_DNS2=$DNS2
	fi

	writeRED $1 $4 $5 "255.255.255.255" $DNSMASQ_DNS1 $DNSMASQ_DNS2

	/usr/bin/sounds/onlinesound
fi

# Restart/reset everything that depends on RED
#
echolog "E" "s" "" "..DNSMasq (DNS1: $DNSMASQ_DNS1; DNS2: $DNSMASQ_DNS2)"
/usr/bin/smoothcom dnsproxyrestart $DNSMASQ_DNS1 $DNSMASQ_DNS2

echolog "E" "s" "" "..RED filtering"
/usr/bin/smoothcom setincoming

/usr/bin/smoothcom setoutgoing
# Part of Roadster's integrated TOFC
#if [ -f /var/smoothwall/outgoing/configErrors.log ]; then
#  tput smso;
#  sed -e 's/^/..  /' /var/smoothwall/outgoing/configErrors.log
#  tput rmso
#fi

echolog "E" "s" "" "..external access rules"
/usr/bin/smoothcom setxtaccess

echolog "E" "s" "$DEBUG_DHCPCD" "..snort, squid, upnpd, TC, DDNS, VPN (as enabled)"
/usr/bin/smoothcom snortrestart
echolog "$crDEBUG" "" "$DEBUG_DHCPCD" "....smoothcom: squidrestart  [`date`]"
/usr/bin/smoothcom squidrestart
echolog "$crDEBUG" "" "$DEBUG_DHCPCD" "....smoothcom: upnpdrestart [`date`]"
/usr/bin/smoothcom upnpdrestart
echolog "$crDEBUG" "" "$DEBUG_DHCPCD" "....smoothcom: trafficrestart [`date`]"
/usr/bin/smoothcom trafficrestart

/usr/bin/smoothwall/setddns.pl

/etc/rc.d/rc.vpn.up

# Adapted from Steve McNeill's ModInstall
echolog "E" "s" "" "..running mods' 'on RED up' scripts"
# if any; limited to .../mods/*/etc/rc.d
shopt -s nullglob
for i in /var/smoothwall/mods/*/etc/rc.d/00rc.updatered; do
  $i
done
shopt -u nullglob

# Check updates and register now if during operation. Otherwise, rc.sysinit handles it
if [ "x$STARTSTOP" == "x" ]; then
  # Only do the following the first time RED comes up; it might not be for a while after booting
  #   in the case of PPP. Both must succeed for the flag to be deleted.
  if [ -e /var/run/do_update_machreg ]; then
    echolog "E" "s" "" "..look for system updates; register system."
    /usr/bin/smoothwall/updatelists.pl &&
      /etc/rc.d/rc.machineregister &&
      rm -f /var/run/do_update_machreg
  fi
fi

# exit rc.updatered:
echolog "$crDEBUG" "" "$DEBUG_DHCPCD" "..exit rc.updatered RED_TYPE [$RED_TYPE] ($reason) [`date`]"
